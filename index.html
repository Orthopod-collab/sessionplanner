<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Surgical Session Planner</title>
<style>
  body { background: #f9fafb; color: #111827; font-family: sans-serif; margin: 0; padding: 0; }
  header { padding: 16px; background: #1f2937; color: #fff; font-size: 1.2rem; font-weight: bold; }
  .app { display: flex; flex-wrap: wrap; gap: 14px; padding: 16px; }
  nav { display: flex; flex-direction: column; gap: 8px; }
  nav button { padding: 10px; border: none; border-radius: 6px; background: #e5e7eb; color: #111827; cursor: pointer; transition: background 0.2s; font-size: 1rem; }
  nav button.active, nav button:hover { background: #2563eb; color: white; }
  main { flex: 1; min-width: 280px; background: #fff; padding: 16px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
  label { display: block; margin-top: 12px; font-size: 0.9rem; font-weight: 500; }
  select, textarea, input[type="text"] { width: 100%; padding: 8px; margin-top: 4px; border-radius: 6px; border: 1px solid #d1d5db; background: #fff; color: #111827; font-size: 0.95rem; }
  textarea { min-height: 80px; }
  .btn { padding: 10px; border-radius: 6px; border: none; background: #2563eb; color: white; cursor: pointer; font-size: 1rem; margin-top: 12px; }
  .btn:hover { background: #1d4ed8; }
  table { width: 100%; border-collapse: collapse; margin-top: 12px; font-size: 0.9rem; }
  th, td { border-bottom: 1px solid #e5e7eb; padding: 8px; text-align: left; vertical-align: top; }
  mark { background: #fde047; padding: 0 2px; border-radius: 2px; }
  @media (max-width: 700px) {
    .app { flex-direction: column; }
    nav { flex-direction: row; overflow-x: auto; }
    nav button { flex: 1; min-width: 120px; }
  }
</style>
</head>
<body>
<header>Surgical Session Planner</header>
<div class="app">
  <nav>
    <button class="active" data-tab="builder">Builder</button>
    <button data-tab="matcher">Requirement Matcher</button>
  </nav>
  <main>
    <section id="builderTab">
      <label>Specialty
        <select id="specialty">
          <option>Applies to All</option><option>ENT</option><option>OMFS</option><option>Orthopaedics</option><option>Plastics</option><option>Neurosurgery</option><option>Renal</option><option>Vascular</option><option>Pain</option><option>Ophthalmology</option><option>Gynaecology</option><option>Urology</option><option>Colorectal</option><option>UGI</option><option>HPB</option><option>Endoscopy</option><option>Anaesthetics</option>
        </select>
      </label>
      <label>Requirement
        <select id="requirement">
          <option>Laser RN</option><option>Extra Scrub RN/ODP</option><option>Cell Salvage RN/ODP</option><option>Floater</option><option>Change list order</option><option>In-patient bed</option><option>2 cases in AM</option><option>8 cases in 2 sessions</option><option>No Need for Extra RN</option><option>4 hours duration</option><option>6 hours duration</option><option>Requires ENT nurse</option><option>Implant Review</option><option>Extra Robotic RN</option>
        </select>
      </label>
      <label>Keywords (comma-separated)
        <textarea id="keywords"></textarea>
      </label>
      <button class="btn" id="saveMapping">Save mapping</button>
      <table id="mapTable"><thead><tr><th>Specialty</th><th>Requirement</th><th>Keywords</th><th>Actions</th></tr></thead><tbody></tbody></table>
    </section>

    <section id="matcherTab" style="display:none">
      <label>Paste description
        <textarea id="inputText" placeholder="Type or paste a descriptionâ€¦"></textarea>
      </label>
      <button class="btn" id="runMatch" style="margin-top:12px;">Match requirements</button>
      <div id="highlight" style="margin-top:10px;color:#374151">No text yet.</div>
      <div id="results" style="margin-top:10px;color:#374151">Nothing matched yet.</div>
    </section>
  </main>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
  import { getFirestore, collection, addDoc, updateDoc, deleteDoc, doc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCQW7EokI7uns6X9jxQnvIWX0SvDU68218",
    authDomain: "session-planner-1ef14.firebaseapp.com",
    projectId: "session-planner-1ef14",
    storageBucket: "session-planner-1ef14.firebasestorage.app",
    messagingSenderId: "17833265107",
    appId: "1:17833265107:web:3889ae3e98bbe45f98d126",
    measurementId: "G-J74KX24JP7"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const $ = (q, r=document) => r.querySelector(q);
  const tbody = $('#mapTable tbody');

  let mappings = [];
  let editId = null;
  const mappingsRef = collection(db, 'mappings');

  const escapeRegExp = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  function levenshtein(a, b) {
    if (a === b) return 0;
    const al = a.length, bl = b.length;
    if (al === 0) return bl;
    if (bl === 0) return al;
    const dp = Array(bl + 1).fill(0).map((_, i) => i);
    for (let i = 1; i <= al; i++) {
      let prev = dp[0];
      dp[0] = i;
      for (let j = 1; j <= bl; j++) {
        const tmp = dp[j];
        dp[j] = Math.min(
          dp[j] + 1,
          dp[j - 1] + 1,
          prev + (a[i - 1] === b[j - 1] ? 0 : 1)
        );
        prev = tmp;
      }
    }
    return dp[bl];
  }

  const tokenize = (t) => t
    .toLowerCase()
    .replace(/[^a-z0-9\s/-]/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .split(' ')
    .filter(Boolean);

  const detokenize = (tokens) => tokens.join(' ');

  const manualOverrides = [
    ['at call to me', 'atticotomy'],
    ['attico to me', 'atticotomy'],
    ['attico tommy', 'atticotomy'],
    ['attica tomy', 'atticotomy'],
  ];

  let keywordPhrases = [];
  let keywordTokens = [];
  let keywordTokenLengths = new Set([1]);

  function refreshKeywordIndex() {
    const all = new Set();
    mappings.forEach(m => (m.keywords || []).forEach(k => all.add(String(k).trim()).add(String(k).trim().toLowerCase())));
    keywordPhrases = Array.from(all).filter(Boolean);
    keywordTokens = keywordPhrases.map(p => tokenize(p));
    keywordTokenLengths = new Set(keywordTokens.map(toks => toks.length));
    keywordTokenLengths = new Set(Array.from(keywordTokenLengths).filter(n => n > 0 && n <= 5));
  }

  function autoCorrectAgainstKeywords(input) {
    let text = input;
    for (const [wrong, right] of manualOverrides) {
      const re = new RegExp(`\\b${escapeRegExp(wrong)}\\b`, 'gi');
      text = text.replace(re, right);
    }
    const original = text;
    const srcTokens = tokenize(original);
    if (!srcTokens.length || keywordPhrases.length === 0) return text;

    const replacements = [];
    const maxSrcIndex = srcTokens.length - 1;

    const kwByLen = {};
    keywordTokens.forEach((toks, idx) => {
      const L = toks.length;
      kwByLen[L] ||= [];
      kwByLen[L].push({ toks, phrase: keywordPhrases[idx] });
    });

    for (const L of Array.from(keywordTokenLengths).sort((a,b)=>a-b)) {
      if (L > srcTokens.length) continue;
      const candidates = kwByLen[L] || [];
      if (!candidates.length) continue;

      for (let i = 0; i + L - 1 <= maxSrcIndex; i++) {
        const windowTokens = srcTokens.slice(i, i + L);
        const windowText = detokenize(windowTokens);

        let best = null;
        for (const { toks, phrase } of candidates) {
          const kwText = detokenize(toks);
          const dist = levenshtein(windowText, kwText);
          const norm = dist / Math.max(kwText.length, 1);
          if (!best || norm < best.norm) best = { norm, phrase, kwText };
        }

        if (best && best.norm > 0 && best.norm <= 0.34 && windowText !== best.kwText) {
          replacements.push({ start: i, end: i + L, replacement: best.phrase, score: best.norm });
        }
      }
    }

    replacements.sort((a, b) => a.score - b.score || (b.end - b.start) - (a.end - a.start));
    const chosen = [];
    let occupied = Array(srcTokens.length).fill(false);
    for (const r of replacements) {
      let overlaps = false;
      for (let k = r.start; k < r.end; k++) { if (occupied[k]) { overlaps = true; break; } }
      if (!overlaps) {
        chosen.push(r);
        for (let k = r.start; k < r.end; k++) occupied[k] = true;
      }
    }

    if (!chosen.length) return text;

    const out = [];
    let idx = 0;
    const byStart = {};
    chosen.forEach(r => { byStart[r.start] = r; });
    while (idx < srcTokens.length) {
      if (byStart[idx]) {
        const r = byStart[idx];
        out.push(...tokenize(r.replacement));
        idx = r.end;
      } else {
        out.push(srcTokens[idx]);
        idx++;
      }
    }

    let corrected = out.join(' ');
    corrected = corrected.replace(/\s+([.,;:!?])/g, '$1');
    return corrected;
  }

  function renderTable(){
    tbody.innerHTML = '';
    mappings.forEach(m => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${m.specialty}</td><td>${m.requirement}</td><td>${(m.keywords||[]).join(', ')}</td><td><button data-edit="${m.id}">Edit</button> <button data-del="${m.id}">Delete</button></td>`;
      tbody.appendChild(tr);
    });
    tbody.querySelectorAll('button[data-del]').forEach(btn => btn.onclick = async () => {
      await deleteDoc(doc(db, 'mappings', btn.dataset.del));
    });
    tbody.querySelectorAll('button[data-edit]').forEach(btn => btn.onclick = () => {
      const m = mappings.find(x => x.id === btn.dataset.edit);
      $('#specialty').value = m.specialty;
      $('#requirement').value = m.requirement;
      $('#keywords').value = (m.keywords||[]).join(', ');
      editId = m.id;
      $('#saveMapping').textContent = 'Update mapping';
    });
  }

  $('#saveMapping').onclick = async () => {
    const specialty = $('#specialty').value.trim();
    const requirement = $('#requirement').value.trim();
    const keywords = $('#keywords').value.split(',').map(k=>k.trim()).filter(Boolean);
    if(!keywords.length) return alert('Please add keywords');
    if(editId){
      await updateDoc(doc(db, 'mappings', editId), { specialty, requirement, keywords });
      editId = null;
      $('#saveMapping').textContent = 'Save mapping';
    } else {
      await addDoc(mappingsRef, { specialty, requirement, keywords });
    }
    $('#keywords').value = '';
  };

  onSnapshot(mappingsRef, snap => {
    mappings = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    renderTable();
    refreshKeywordIndex();
  });

  function runMatch(){
    const raw = $('#inputText').value;
    if(!raw.trim()) return alert('Paste some text first');

    const corrected = autoCorrectAgainstKeywords(raw);
    if (corrected !== raw) $('#inputText').value = corrected;

    const text = corrected.toLowerCase();
    const results = [];
    const hits = new Set();

    mappings.forEach(m => {
      const found = (m.keywords || []).filter(k => text.includes(String(k).toLowerCase()));
      if(found.length) {
        results.push({ specialty: m.specialty, requirement: m.requirement, hits: found });
        found.forEach(f => hits.add(String(f).toLowerCase()));
      }
    });

    if(!results.length){
      $('#results').innerHTML = '<span style="color:#6b7280">No requirements inferred.</span>';
    } else {
      $('#results').innerHTML = results.map(r => `<div><strong>${r.specialty}</strong> â€” ${r.requirement} (keywords: ${r.hits.join(', ')})</div>`).join('');
    }

    let highlighted = corrected;
    hits.forEach(k => {
      highlighted = highlighted.replace(new RegExp(escapeRegExp(k), 'gi'), m => `<mark>${m}</mark>`);
    });
    $('#highlight').innerHTML = highlighted;
  }

  $('#runMatch').onclick = runMatch;

  document.querySelectorAll('nav button[data-tab]').forEach(btn => btn.onclick = () => {
    document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    $('#builderTab').style.display = btn.dataset.tab === 'builder' ? 'block' : 'none';
    $('#matcherTab').style.display = btn.dataset.tab === 'matcher' ? 'block' : 'none';
  });
</script>
</body>
</html>
